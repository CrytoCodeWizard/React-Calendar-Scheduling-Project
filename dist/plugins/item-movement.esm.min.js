/**
 * TimelinePointer plugin
 *
 * @copyright NEURONET - Rafal Pospiech
 * @author    Rafal Pospiech <neuronet.io@gmail.com>
 * @module    gantt-schedule-timeline-calendar
 * @link      https://github.com/neuronetio/gantt-schedule-timeline-calendar
 * @link      https://gantt-schedule-timeline-calendar.neuronet.io
 * @version   3.25.2
 * @released  2022-06-30
 * @license   SEE LICENSE IN LICENSE FILE
 */
const t="chart-timeline-items-row-item";
/**
 * ItemMovement plugin
 *
 * @copyright NEURONET - Rafal Pospiech
 * @author    Rafal Pospiech <neuronet.io@gmail.com>
 * @module    gantt-schedule-timeline-calendar
 * @link      https://github.com/neuronetio/gantt-schedule-timeline-calendar
 * @link      https://gantt-schedule-timeline-calendar.neuronet.io
 * @version   3.25.2
 * @released  2022-06-30
 * @license   SEE LICENSE IN LICENSE FILE
 */class e{constructor(t,e){this.onDestroy=[],this.scrollWaiting=0,this.vido=t,this.state=t.state,this.api=t.api,this.data=function(t={}){const e={onStart:({items:t})=>t.after,onMove:({items:t})=>t.after,onEnd:({items:t})=>t.after},i={start:({startTime:t,time:e})=>t.startOf(e.period),end:({endTime:t})=>t},a={speed:{horizontal:1,vertical:1},edgeThreshold:{horizontal:0,vertical:0}},s=Object.assign({enabled:!0,dependant:!0,moveDependantVertically:!1,addedDependantIds:[],selectedIds:[],debug:!1,state:"",bodyClass:"gstc-items-moving",itemClass:"",movement:{x:0,y:0,time:0},threshold:{horizontal:10,vertical:10},initialItems:[],initialItemsData:{},clickedItem:null,clickedItemData:null,initialVerticalScroll:null,initialHorizontalScroll:null,initialPointerTime:null,isMoving:!1,events:Object.assign({},e),snapToTime:Object.assign({},i),autoScroll:Object.assign({},a),ignoreMissingDates:!0},t);return t.snapToTime&&(s.snapToTime=Object.assign(Object.assign({},i),t.snapToTime)),t.events&&(s.events=Object.assign(Object.assign({},e),t.events)),t.autoScroll&&(s.autoScroll=Object.assign(Object.assign({},a),t.autoScroll),t.autoScroll.edgeThreshold&&(s.autoScroll.edgeThreshold=Object.assign(Object.assign({},a.edgeThreshold),t.autoScroll.edgeThreshold)),t.autoScroll.speed&&(s.autoScroll.speed=Object.assign(Object.assign({},a.speed),t.autoScroll.speed))),s}(e),this.data.itemClass||(this.data.itemClass=this.api.getClass("timeline-chart-items-row-item")+"--moving"),this.destroy=this.destroy.bind(this),this.itemUpdateAction=this.itemUpdateAction.bind(this),this.onDestroy.push(this.state.subscribe("$data.elements.chart-timeline",(t=>this.timelineElement=t))),this.updateData(),this.onDestroy.push(this.state.subscribe("config.plugin.ItemMovement",(t=>{t.enabled&&t.isMoving?document.body.classList.add(t.bodyClass):document.body.classList.remove(t.bodyClass),this.data=t}))),this.onPointerMove=this.onPointerMove.bind(this),this.onPointerUp=this.onPointerUp.bind(this),this.onDestroy.push(this.state.subscribe("config.plugin.TimelinePointer",(t=>{this.pointerData=t,this.onPointerData()})))}destroy(){this.onDestroy.forEach((t=>t())),this.api.pluginDestroyed("ItemMovement")}updateData(){this.state.update("config.plugin.ItemMovement",this.data)}getSelectedItems(e=!1){return this.state.get(`config.plugin.Selection.selected.${t}`).map((t=>{let i=this.api.getItem(t);if(e)for(const e of this.data.initialItems)if(e.id===t){i=e;break}return this.api.mergeDeep({},i)}))}getSelectedItemsData(t){const e={};for(const i of t)e[i.id]=this.api.mergeDeep({},this.api.getItemData(i.id));return e}getEventArgument(t){const e=this.api.getAllItems(),i=[];for(const a of t)i.push(this.api.mergeDeep({},e[a.id]));return{items:{initial:this.data.initialItems,before:i,after:t,targetData:this.pointerData.targetData},addedDependantIds:this.data.addedDependantIds,selectedIds:this.data.selectedIds,vido:this.vido,state:this.state,time:this.state.get("$data.chart.time")}}getDependantItems(t,e){const i=[],a=this.api.getItemsData();for(const e of t)for(const t of a[e.id].dependant)i.includes(t)||i.push(t);const s=this.state.get("config.chart.items");let o;return o=e?i.map((t=>this.data.initialItems.find((e=>e.id===t)))):i.map((t=>s[t])),o.map((t=>this.api.mergeDeep({},t)))}dispatchEvent(t,e,i=null){"onStart"===t&&(this.api.muteMethod("fixOverlapped"),this.api.muteMethod("fullReload"),this.api.muteMethod("measureRows"),this.api.muteMethod("getLastPageRowsHeight"),this.api.muteMethod("calculateVerticalScrollArea"),this.api.muteMethod("heightChange"),this.api.muteMethod("calculateRowsHeight"),this.api.muteMethod("calculateVisibleRowsHeights"),this.api.muteMethod("updateVisibleItemsListener"),this.api.muteMethod("prepareExpanded"),0===this.data.autoScroll.speed.horizontal&&0===this.data.autoScroll.speed.vertical&&(this.api.muteMethod("generateVisibleRowsAndItems"),this.api.muteMethod("prepareExpanded"))),"onEnd"===t&&(this.api.unmuteMethod("fixOverlapped"),this.api.unmuteMethod("heightChange"),this.api.unmuteMethod("calculateVerticalScrollArea"),this.api.unmuteMethod("getLastPageRowsHeight"),this.api.unmuteMethod("fullReload"),this.api.unmuteMethod("measureRows"),this.api.unmuteMethod("calculateRowsHeight"),this.api.unmuteMethod("calculateVisibleRowsHeights"),this.api.unmuteMethod("updateVisibleItemsListener"),this.api.unmuteMethod("prepareExpanded"),0===this.data.autoScroll.speed.horizontal&&0===this.data.autoScroll.speed.vertical&&(this.api.unmuteMethod("generateVisibleRowsAndItems"),this.api.unmuteMethod("prepareExpanded"))),e=e.map((t=>this.api.mergeDeep({},t)));const a=this.data.events[t](this.getEventArgument(e));let s=this.state.multi(!0);const o=this.state.get("config.chart.items");for(let t of a){t=this.api.mergeDeep({},t);const e=o[t.id];let a=!1;t.time.start===e.time.start&&t.time.end===e.time.end||(a=!0,s=s.update(`config.chart.items.${t.id}.time`,Object.assign({},t.time)));let n=!1;e.rowId!==t.rowId&&(n=!0,s=s.update(`config.chart.items.${t.id}.rowId`,t.rowId),this.api.updateItemRowMapForItem(t.id,t.rowId)),i&&(a||n)&&(s=s.update(`$data.chart.items.${t.id}`,this.api.mergeDeep({},i[t.id])))}s.done(),"onEnd"===t&&this.api.main.partialReload(!1)}getItemsForDiff(){const t=this.getSelectedItems()[0],e=this.data.initialItems.find((e=>e.id===t.id));return{modified:t,original:e}}onPointerData(){this.data.enabled&&("down"===this.pointerData.pointerState&&this.pointerData.targetType===t?this.api.plugins.TimelinePointer.isLocked("down")||this.triggerDown():"move"===this.pointerData.pointerState&&this.pointerData.targetType===t?"item-movement"===this.api.plugins.TimelinePointer.isLocked("move")&&this.onPointerMove():"up"===this.pointerData.pointerState&&this.pointerData.targetType===t&&"item-movement"===this.api.plugins.TimelinePointer.isLocked("up")&&this.onPointerUp())}triggerDown(){if(document.body.classList.add(this.data.bodyClass),this.api.plugins.TimelinePointer.lock("down","item-movement"),this.api.plugins.TimelinePointer.lock("move","item-movement"),this.api.plugins.TimelinePointer.lock("up","item-movement"),this.data.isMoving=!0,this.data.dependant){const t=this.getSelectedItems();this.data.selectedIds=t.map((t=>t.id));const e=this.getDependantItems(t,!1).filter((t=>!this.data.selectedIds.includes(t.id)));this.data.addedDependantIds=e.map((t=>t.id)),this.data.initialItems=[...t,...e]}else this.data.addedDependantIds=[],this.data.initialItems=this.getSelectedItems(),this.data.selectedIds=this.data.initialItems.map((t=>t.id));this.data.initialItemsData=this.getSelectedItemsData(this.data.initialItems),this.data.clickedItem=this.api.mergeDeep({},this.pointerData.targetData),this.data.clickedItemData=this.api.mergeDeep({},this.api.getItemData(this.data.clickedItem.id)),this.data.initialVerticalScroll=this.api.mergeDeep({},this.state.get("$data.scroll.vertical")),this.data.initialHorizontalScroll=this.api.mergeDeep({},this.state.get("$data.scroll.horizontal")),this.data.initialPointerTime=this.api.time.date(this.api.time.getTimeFromOffsetPx(this.pointerData.initialPosition.x,!0)),this.scrollWaiting=0,""!==this.data.state&&"end"!==this.data.state||(this.data.state="move"),this.dispatchEvent("onStart",this.data.initialItems),this.updateData()}scrollLeft(){if(this.data.autoScroll.speed.horizontal&&!this.state.get("config.chart.time.calculatedZoomMode")){if(this.scrollWaiting++,this.data.autoScroll.speed.horizontal<0){if(this.scrollWaiting-1<Math.abs(this.data.autoScroll.speed.horizontal))return;const t=this.api.getScrollLeft();this.api.setScrollLeft(t.dataIndex-1)}else if(this.data.autoScroll.speed.horizontal>0){const t=this.api.getScrollLeft();this.api.setScrollLeft(t.dataIndex-this.data.autoScroll.speed.horizontal)}this.scrollWaiting=0}}scrollRight(){if(this.data.autoScroll.speed.horizontal&&!this.state.get("config.chart.time.calculatedZoomMode")){if(this.scrollWaiting++,this.data.autoScroll.speed.horizontal<0){if(this.scrollWaiting-1<Math.abs(this.data.autoScroll.speed.horizontal))return;const t=this.api.getScrollLeft();this.api.setScrollLeft(t.dataIndex+1)}else if(this.data.autoScroll.speed.horizontal>0){const t=this.api.getScrollLeft();this.api.setScrollLeft(t.dataIndex+this.data.autoScroll.speed.horizontal)}this.scrollWaiting=0}}scrollTop(){if(this.data.autoScroll.speed.vertical){if(this.scrollWaiting++,this.data.autoScroll.speed.vertical<0){if(this.scrollWaiting-1<Math.abs(this.data.autoScroll.speed.vertical))return;const t=this.api.getScrollTop();this.api.setScrollTop(t.dataIndex-1)}else if(this.data.autoScroll.speed.vertical>0){const t=this.api.getScrollTop();this.api.setScrollTop(t.dataIndex-this.data.autoScroll.speed.vertical)}this.scrollWaiting=0}}scrollBottom(){if(this.data.autoScroll.speed.vertical){if(this.scrollWaiting++,this.data.autoScroll.speed.vertical<0){if(this.scrollWaiting-1<Math.abs(this.data.autoScroll.speed.vertical))return;const t=this.api.getScrollTop();this.api.setScrollTop(t.dataIndex+1)}else if(this.data.autoScroll.speed.vertical>0){const t=this.api.getScrollTop();this.api.setScrollTop(t.dataIndex+this.data.autoScroll.speed.vertical)}this.scrollWaiting=0}}autoScroll(){if(!this.timelineElement)return;const t=this.pointerData.currentPosition.x,e=this.pointerData.currentPosition.y,i=this.state.get("$data.chart.dimensions");t<this.data.autoScroll.edgeThreshold.horizontal?this.scrollLeft():t>i.widthWithoutScrollBar-this.data.autoScroll.edgeThreshold.horizontal?this.scrollRight():e<this.data.autoScroll.edgeThreshold.vertical?this.scrollTop():e>i.innerHeight-this.data.autoScroll.edgeThreshold.vertical&&this.scrollBottom()}moveItemVertically(t,e){if(this.data.addedDependantIds.includes(t.id)&&!this.data.moveDependantVertically)return;const i=this.state.get("$data.scroll.vertical").absolutePosPx-this.data.initialVerticalScroll.absolutePosPx,a=this.pointerData.currentPosition.y-this.pointerData.initialPosition.y,s=this.data.clickedItemData.position.viewTop-this.pointerData.initialPosition.y-this.data.clickedItemData.position.rowTop;let o=e.position.top+a+i-s;o<0&&(o=0);const n=this.api.getRowInfoFromTop(o);n.row.id!==t.rowId&&(t.rowId=n.row.id,e.position.viewTop=this.api.getRowViewTop(t.rowId),e.position.rowTop=0)}onPointerMove(){if(!this.data.enabled)return;if(!this.data.isMoving)return;const{original:t,modified:e}=this.getItemsForDiff();if(!t)return;const i=this.data.movement=Object.assign(Object.assign({},this.pointerData.movement),{time:e.time.start-t.time.start});"move"!==this.data.state&&"start"!==this.data.state||(this.data.state="move");let a,s=[];if(this.data.dependant){const t=this.getSelectedItems(!0),e=t.map((t=>t.id)),i=this.getDependantItems(t,!0).filter((t=>!e.includes(t.id)));s=i.map((t=>t.id)),a=[...t,...i]}else a=this.getSelectedItems(!0);const o={},n=this.state.get("$data.chart.time"),l=[],d=this.data.snapToTime.start({startTime:this.data.initialPointerTime,item:null,time:n,movement:i,vido:this.vido}),h=this.state.get("$data.scroll.horizontal"),r=this.api.time.getDatesDiffPx(h.data.leftGlobalDate,this.data.initialHorizontalScroll.data.leftGlobalDate,n,!0),m=this.api.time.date(this.api.time.getTimeFromOffsetPx(this.pointerData.currentPosition.x+r,!0,n)),c=this.api.time.getDatesDiffPx(d,m,n,!0);for(let t=0,e=a.length;t<e;t++){const e=this.api.mergeDeep({},a[t]),d=this.api.mergeDeep({},this.data.initialItemsData[e.id]),h=s.includes(e.id);this.moveItemVertically(e,d);const r=d.position.left+c;let m=this.api.time.getTimeFromOffsetPx(r,!0,n);if(h){const t=this.data.initialItems.find((t=>t.dependant.includes(e.id))),i=this.data.initialItemsData[t.id],a=o[i.id],s=this.api.time.getDatesDiffMs(i.time.endDate,a.time.endDate,n,!0);let l=-this.api.time.getDSTDiffForLevel(n.level,i.time.endDate.valueOf(),d.time.startDate.valueOf(),n);m=this.api.time.addTimeFromDates(d.time.startDate.valueOf(),s+l,n),l=this.api.time.getDSTDiffForLevel(n.level,a.time.endDate.valueOf(),m,n),m+=l}const p=this.api.time.date(m);let u=p;h||(u=this.data.snapToTime.start({startTime:p,item:e,time:n,movement:i,vido:this.vido}));const g=u.valueOf(),f=this.api.time.getViewOffsetPxFromDates(u,!1,n);let v=-this.api.time.getDSTDiffForLevel(n.level,e.time.start,e.time.end,n);const D=f+d.timeWidth;let I;const S=e.time.end-e.time.start;I=this.data.ignoreMissingDates?this.api.time.date(this.api.time.getTimeFromOffsetPx(D,!0,n)):this.api.time.date(u.valueOf()+S),v+=this.api.time.getDSTDiffForLevel(n.level,g,I.valueOf(),n),I=I.add(v,"ms");let T=I;h||(T=this.data.snapToTime.end({endTime:I,item:e,time:n,movement:i,vido:this.vido})),e.time.start=u.valueOf(),e.time.end=T.valueOf(),d.time.startDate=u,d.time.endDate=T,o[e.id]=d,l.push(e)}this.dispatchEvent("onMove",l,o),c&&this.autoScroll(),this.updateData()}onEnd(){const t=this.getSelectedItems();this.dispatchEvent("onEnd",t)}onPointerUp(){document.body.classList.remove(this.data.bodyClass),this.data.enabled&&this.data.isMoving&&("move"===this.data.state&&(this.data.state="end"),this.data.isMoving=!1,this.onEnd(),this.updateData(),this.api.plugins.TimelinePointer.unlock("down"),this.api.plugins.TimelinePointer.unlock("move"),this.api.plugins.TimelinePointer.unlock("up"))}itemUpdateAction(t,e){this.data.initialItems.find((t=>t.id===e.item.id))&&this.data.isMoving?t.classList.add(this.data.itemClass):t.classList.remove(this.data.itemClass)}}function i(t={}){return function(i){const a=i.api;if(!a.isPluginInitialized("TimelinePointer"))throw new Error("TimelinePointer plugin must be initialized before ItemMovement plugin.");if(!a.isPluginInitialized("Selection"))throw new Error("Selection plugin must be initialized before ItemMovement plugin.");const s=i.state.get("config.plugin.ItemMovement");s&&(t=i.api.mergeDeep({},t,s));const o=new e(i,t);return a.pluginInitialized("ItemMovement"),o.destroy}}export{i as Plugin};