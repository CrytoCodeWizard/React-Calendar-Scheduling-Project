/**
 * TimelinePointer plugin
 *
 * @copyright NEURONET - Rafal Pospiech <https://neuronet.io>
 * @author    Rafal Pospiech <neuronet@neuronet.io>
 * @module    gantt-schedule-timeline-calendar
 * @link      https://github.com/neuronetio/gantt-schedule-timeline-calendar
 * @version   3.16.1
 * @released  2022-01-06
 * @license   SEE LICENSE IN LICENSE FILE
 */
const t="chart-timeline-items-row-item";
/**
 * ItemMovement plugin
 *
 * @copyright NEURONET - Rafal Pospiech <https://neuronet.io>
 * @author    Rafal Pospiech <neuronet@neuronet.io>
 * @module    gantt-schedule-timeline-calendar
 * @link      https://github.com/neuronetio/gantt-schedule-timeline-calendar
 * @version   3.16.1
 * @released  2022-01-06
 * @license   SEE LICENSE IN LICENSE FILE
 */class i{constructor(t,i){this.onDestroy=[],this.scrollWaiting=0,this.vido=t,this.state=t.state,this.api=t.api,this.data=function(t={}){const i={onStart:({items:t})=>t.after,onMove:({items:t})=>t.after,onEnd:({items:t})=>t.after},e={start:({startTime:t,time:i})=>t.startOf(i.period),end:({endTime:t,time:i})=>t.endOf(i.period)},a={speed:{horizontal:1,vertical:1},edgeThreshold:{horizontal:100,vertical:100}},s=Object.assign({enabled:!0,dependant:!0,debug:!1,state:"",bodyClass:"gstc-items-moving",itemClass:"",movement:{x:0,y:0,time:0},threshold:{horizontal:10,vertical:10},initialItems:[],initialDependant:[],initialItemsData:{},initialDependantData:{},clickedItem:null,clickedItemData:null,initialVerticalScroll:null,initialHorizontalScroll:null,isMoving:!1,events:Object.assign({},i),snapToTime:Object.assign({},e),autoScroll:Object.assign({},a)},t);return t.snapToTime&&(s.snapToTime=Object.assign(Object.assign({},e),t.snapToTime)),t.events&&(s.events=Object.assign(Object.assign({},i),t.events)),t.autoScroll&&(s.autoScroll=Object.assign(Object.assign({},a),t.autoScroll),t.autoScroll.edgeThreshold&&(s.autoScroll.edgeThreshold=Object.assign(Object.assign({},a.edgeThreshold),t.autoScroll.edgeThreshold)),t.autoScroll.speed&&(s.autoScroll.speed=Object.assign(Object.assign({},a.speed),t.autoScroll.speed))),s}(i),this.data.itemClass||(this.data.itemClass=this.api.getClass("timeline-chart-items-row-item")+"--moving"),this.destroy=this.destroy.bind(this),this.itemUpdateAction=this.itemUpdateAction.bind(this),this.onDestroy.push(this.state.subscribe("$data.elements.chart-timeline",(t=>this.timelineElement=t))),this.updateData(),this.onDestroy.push(this.state.subscribe("config.plugin.ItemMovement",(t=>{t.enabled&&t.isMoving?document.body.classList.add(t.bodyClass):document.body.classList.remove(t.bodyClass),this.data=t}))),this.onPointerMove=this.onPointerMove.bind(this),this.onPointerUp=this.onPointerUp.bind(this),this.onDestroy.push(this.state.subscribe("config.plugin.TimelinePointer",(t=>{this.pointerData=t,this.onPointerData()})))}destroy(){this.onDestroy.forEach((t=>t())),this.api.pluginDestroyed("ItemMovement")}updateData(){this.state.update("config.plugin.ItemMovement",this.data)}getSelectedItems(i=!1){return this.state.get(`config.plugin.Selection.selected.${t}`).map((t=>{let e=this.api.getItem(t);if(i)for(const i of this.data.initialItems)if(i.id===t){e=i;break}return this.api.mergeDeep({},e)}))}getSelectedItemsData(t){const i={};for(const e of t)i[e.id]=this.api.mergeDeep({},this.api.getItemData(e.id));return i}getEventArgument(t){const i=this.api.getAllItems(),e=[];for(const a of t)e.push(this.api.mergeDeep({},i[a.id]));return{items:{initial:this.data.initialItems,before:e,after:t,targetData:this.pointerData.targetData},vido:this.vido,state:this.state,time:this.state.get("$data.chart.time")}}getDependantItems(){const t=[],i=this.api.getItemsData();for(const e of this.data.initialItems)for(const a of i[e.id].dependant)t.includes(a)||t.push(a);const e=this.state.get("config.chart.items");return t.map((t=>e[t])).map((t=>this.api.mergeDeep({},t)))}getDependantItemsData(){const t={},i=this.api.getItemsData();for(const e of this.data.initialDependant)t[e.id]=this.api.mergeDeep({},i[e.id]);return t}moveDependantItems(t,i){if(!this.data.dependant)return i;const e=this.api.getItemsData(),a=this.state.get("config.chart.time");for(const s of t){const t=this.data.initialItems.find((t=>t.id===s.id)),o=this.data.initialItemsData[t.id],n=e[s.id];if(n.dependant.length)for(const t of n.dependant){this.data.initialDependant.find((i=>i.id===t));const e=this.data.initialDependantData[t],s=n.time.endDate.diff(o.time.endDate,"millisecond"),l=e.time.startDate.add(s,"millisecond"),d=e.time.endDate.add(s,"millisecond"),r=n.position.right-e.position.right,h=n.position.viewTop-e.position.viewTop,m=this.data.snapToTime.start({startTime:l,time:a,movement:{x:r,y:h,time:s},vido:this.vido});i=i.update(`config.chart.items.${t}.time`,(t=>(t.start=m.valueOf(),t.end=d.valueOf(),t))),i=i.update(`$data.chart.items.${t}.time`,(t=>(t.startDate=m,t.endDate=d,t)))}}return i}dispatchEvent(t,i,e=null){"onStart"===t&&(this.api.muteMethod("fixOverlapped"),this.api.muteMethod("fullReload"),this.api.muteMethod("measureRows"),this.api.muteMethod("getLastPageRowsHeight"),this.api.muteMethod("calculateVerticalScrollArea"),this.api.muteMethod("heightChange"),this.api.muteMethod("calculateRowsHeight"),this.api.muteMethod("calculateVisibleRowsHeights"),this.api.muteMethod("updateVisibleItemsListener"),this.api.muteMethod("prepareExpanded"),0===this.data.autoScroll.speed.horizontal&&0===this.data.autoScroll.speed.vertical&&(this.api.muteMethod("generateVisibleRowsAndItems"),this.api.muteMethod("prepareExpanded"),this.api.muteMethod("recalculateTimes"))),"onEnd"===t&&(this.api.unmuteMethod("fixOverlapped"),this.api.unmuteMethod("heightChange"),this.api.unmuteMethod("calculateVerticalScrollArea"),this.api.unmuteMethod("getLastPageRowsHeight"),this.api.unmuteMethod("fullReload"),this.api.unmuteMethod("measureRows"),this.api.unmuteMethod("calculateRowsHeight"),this.api.unmuteMethod("calculateVisibleRowsHeights"),this.api.unmuteMethod("updateVisibleItemsListener"),this.api.unmuteMethod("prepareExpanded"),0===this.data.autoScroll.speed.horizontal&&0===this.data.autoScroll.speed.vertical&&(this.api.unmuteMethod("generateVisibleRowsAndItems"),this.api.unmuteMethod("prepareExpanded"),this.api.unmuteMethod("recalculateTimes"))),i=i.map((t=>this.api.mergeDeep({},t)));const a=this.data.events[t](this.getEventArgument(i));let s=this.state.multi(!0),o=!1;const n=this.state.get("config.chart.items");for(let t of a){t=this.api.mergeDeep({},t);const i=n[t.id];let a=!1;t.time.start===i.time.start&&t.time.end===i.time.end||(o=!0,a=!0,s=s.update(`config.chart.items.${t.id}.time`,Object.assign({},t.time)));let l=!1;i.rowId!==t.rowId&&(l=!0,s=s.update(`config.chart.items.${t.id}.rowId`,t.rowId),this.api.updateItemRowMapForItem(t.id,t.rowId)),e&&(a||l)&&(s=s.update(`$data.chart.items.${t.id}`,this.api.mergeDeep({},e[t.id])))}"onStart"!==t&&"onMove"!==t||!o||(s=this.moveDependantItems(a,s)),s.done(),"onEnd"===t&&this.api.main.partialReload(!1)}getItemsForDiff(){const t=this.getSelectedItems()[0],i=this.data.initialItems.find((i=>i.id===t.id));return{modified:t,original:i}}onPointerData(){this.data.enabled&&("down"===this.pointerData.pointerState&&this.pointerData.targetType===t?this.api.plugins.TimelinePointer.isLocked("down")||this.triggerDown():"move"===this.pointerData.pointerState&&this.pointerData.targetType===t?"item-movement"===this.api.plugins.TimelinePointer.isLocked("move")&&this.onPointerMove():"up"===this.pointerData.pointerState&&this.pointerData.targetType===t&&"item-movement"===this.api.plugins.TimelinePointer.isLocked("up")&&this.onPointerUp())}triggerDown(){document.body.classList.add(this.data.bodyClass),this.api.plugins.TimelinePointer.lock("down","item-movement"),this.api.plugins.TimelinePointer.lock("move","item-movement"),this.api.plugins.TimelinePointer.lock("up","item-movement"),this.data.isMoving=!0,this.data.initialItems=this.getSelectedItems(),this.data.initialDependant=this.getDependantItems(),this.data.initialItemsData=this.getSelectedItemsData(this.data.initialItems),this.data.initialDependantData=this.getDependantItemsData(),this.data.clickedItem=this.api.mergeDeep({},this.pointerData.targetData),this.data.clickedItemData=this.api.mergeDeep({},this.api.getItemData(this.data.clickedItem.id)),this.data.initialVerticalScroll=this.api.mergeDeep({},this.state.get("$data.scroll.vertical")),this.data.initialHorizontalScroll=this.api.mergeDeep({},this.state.get("$data.scroll.horizontal")),this.scrollWaiting=0,""!==this.data.state&&"end"!==this.data.state||(this.data.state="move"),this.dispatchEvent("onStart",this.data.initialItems),this.updateData()}scrollLeft(){if(this.data.autoScroll.speed.horizontal&&!this.state.get("config.chart.time.calculatedZoomMode")){if(this.scrollWaiting++,this.data.autoScroll.speed.horizontal<0){if(this.scrollWaiting-1<Math.abs(this.data.autoScroll.speed.horizontal))return;const t=this.api.getScrollLeft();this.api.setScrollLeft(t.dataIndex-1)}else if(this.data.autoScroll.speed.horizontal>0){const t=this.api.getScrollLeft();this.api.setScrollLeft(t.dataIndex-this.data.autoScroll.speed.horizontal)}this.scrollWaiting=0}}scrollRight(){if(this.data.autoScroll.speed.horizontal&&!this.state.get("config.chart.time.calculatedZoomMode")){if(this.scrollWaiting++,this.data.autoScroll.speed.horizontal<0){if(this.scrollWaiting-1<Math.abs(this.data.autoScroll.speed.horizontal))return;const t=this.api.getScrollLeft();this.api.setScrollLeft(t.dataIndex+1)}else if(this.data.autoScroll.speed.horizontal>0){const t=this.api.getScrollLeft();this.api.setScrollLeft(t.dataIndex+this.data.autoScroll.speed.horizontal)}this.scrollWaiting=0}}scrollTop(){if(this.data.autoScroll.speed.vertical){if(this.scrollWaiting++,this.data.autoScroll.speed.vertical<0){if(this.scrollWaiting-1<Math.abs(this.data.autoScroll.speed.vertical))return;const t=this.api.getScrollTop();this.api.setScrollTop(t.dataIndex-1)}else if(this.data.autoScroll.speed.vertical>0){const t=this.api.getScrollTop();this.api.setScrollTop(t.dataIndex-this.data.autoScroll.speed.vertical)}this.scrollWaiting=0}}scrollBottom(){if(this.data.autoScroll.speed.vertical){if(this.scrollWaiting++,this.data.autoScroll.speed.vertical<0){if(this.scrollWaiting-1<Math.abs(this.data.autoScroll.speed.vertical))return;const t=this.api.getScrollTop();this.api.setScrollTop(t.dataIndex+1)}else if(this.data.autoScroll.speed.vertical>0){const t=this.api.getScrollTop();this.api.setScrollTop(t.dataIndex+this.data.autoScroll.speed.vertical)}this.scrollWaiting=0}}autoScroll(){if(!this.timelineElement)return;const t=this.pointerData.currentPosition.x,i=this.pointerData.currentPosition.y,e=this.state.get("$data.chart.dimensions");t<this.data.autoScroll.edgeThreshold.horizontal?this.scrollLeft():t>e.widthWithoutScrollBar-this.data.autoScroll.edgeThreshold.horizontal?this.scrollRight():i<this.data.autoScroll.edgeThreshold.vertical?this.scrollTop():i>e.innerHeight-this.data.autoScroll.edgeThreshold.vertical&&this.scrollBottom()}moveItemVertically(t,i){const e=this.state.get("$data.scroll.vertical").absolutePosPx-this.data.initialVerticalScroll.absolutePosPx,a=this.pointerData.currentPosition.y-this.pointerData.initialPosition.y,s=this.data.clickedItemData.position.viewTop-this.pointerData.initialPosition.y-this.data.clickedItemData.position.rowTop;let o=i.position.top+a+e-s;o<0&&(o=0);const n=this.api.getRowInfoFromTop(o);n.row.id!==t.rowId&&(t.rowId=n.row.id,i.position.viewTop=this.api.getRowViewTop(t.rowId),i.position.rowTop=0)}onPointerMove(){if(!this.data.enabled)return;if(!this.data.isMoving)return;const{original:t,modified:i}=this.getItemsForDiff();if(!t)return;const e=this.data.movement=Object.assign(Object.assign({},this.pointerData.movement),{time:i.time.start-t.time.start});"move"!==this.data.state&&"start"!==this.data.state||(this.data.state="move");const a=this.getSelectedItems(!0),s={},o=this.state.get("$data.chart.time"),n=[],l=this.api.time.date(this.api.time.getTimeFromOffsetPx(this.pointerData.initialPosition.x,!0,o)),d=this.data.snapToTime.start({startTime:l,time:o,movement:e,vido:this.vido}),r=this.api.time.date(this.api.time.getTimeFromOffsetPx(this.pointerData.currentPosition.x,!0,o)),h=this.data.snapToTime.start({startTime:r,time:o,movement:e,vido:this.vido}),m=this.api.time.getDatesDiffPx(d,h,o,!0);for(let t=0,i=a.length;t<i;t++){const i=this.api.mergeDeep({},a[t]),l=this.api.mergeDeep({},this.data.initialItemsData[i.id]);this.moveItemVertically(i,l);const d=l.position.left+m,r=this.api.time.getTimeFromOffsetPx(d,!0,o),h=this.api.time.date(r),p=this.data.snapToTime.start({startTime:h,time:o,movement:e,vido:this.vido});l.position.left=this.api.time.getViewOffsetPxFromDates(p,!1,o);const c=l.position.left+l.width,u=this.api.time.date(this.api.time.getTimeFromOffsetPx(c,!0,o)),g=this.data.snapToTime.end({endTime:u,time:o,movement:e,vido:this.vido});l.position.right=this.api.time.getViewOffsetPxFromDates(g,!1,o),i.time.start=p.valueOf(),i.time.end=g.valueOf(),l.time.startDate=p,l.time.endDate=g,l.position.right=this.api.time.getGlobalOffsetPxFromDates(g,o),s[i.id]=l,n.push(i)}this.dispatchEvent("onMove",n,s),this.autoScroll(),this.updateData()}onEnd(){const t=this.getSelectedItems();this.dispatchEvent("onEnd",t)}onPointerUp(){document.body.classList.remove(this.data.bodyClass),this.data.enabled&&this.data.isMoving&&("move"===this.data.state&&(this.data.state="end"),this.data.isMoving=!1,this.onEnd(),this.updateData(),this.api.plugins.TimelinePointer.unlock("down"),this.api.plugins.TimelinePointer.unlock("move"),this.api.plugins.TimelinePointer.unlock("up"))}itemUpdateAction(t,i){this.data.initialItems.find((t=>t.id===i.item.id))&&this.data.isMoving?t.classList.add(this.data.itemClass):t.classList.remove(this.data.itemClass)}}function e(t={}){return function(e){const a=e.api;if(!a.isPluginInitialized("TimelinePointer"))throw new Error("TimelinePointer plugin must be initialized before ItemMovement plugin.");if(!a.isPluginInitialized("Selection"))throw new Error("Selection plugin must be initialized before ItemMovement plugin.");const s=e.state.get("config.plugin.ItemMovement");s&&(t=e.api.mergeDeep({},t,s));const o=new i(e,t);return a.pluginInitialized("ItemMovement"),o.destroy}}export{e as Plugin};